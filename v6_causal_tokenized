# %%
import numpy as np
import torch 
import matplotlib.pyplot as plt

# %%
class Mesh:
  def __init__(self, edges: torch.Tensor):
    self.edges = edges
    self.edge_lens = torch.norm(edges[:,0] - edges[:,1], dim=1)
  
  def loop(vertices):
    edges = torch.cat([vertices[:-1], vertices[1:]],dim=1).reshape(-1, 2, 2)
    return Mesh(edges)
  
  def plot(self, c='b'):
    for edge in self.edges:
      plt.plot(*edge.T, c)
    
  def pointcloud(self,n=1000,std = 0.01):
    edges_probs = self.edge_lens/self.edge_lens.sum()
    edges = torch.multinomial(edges_probs, n, replacement=True)
    edges = self.edges[edges]
    t = torch.rand(n)
    points = edges[:,0] + t[:,None]*(edges[:,1]-edges[:,0])
    noise = torch.randn_like(points)*std
    return points + noise
  
box = Mesh.loop(torch.tensor([[0, 0], [0, 1], [1, 1],[1,0], [0,0]],dtype=torch.float32))
box.plot()
# %%
def random_shape():
  n = np.random.randint(3, 10)
  corners = []

  for i in range(n):
    angle = 2*np.pi*i/n + np.random.rand()*0.1
    r = np.random.rand() * 0.5 + 0.5
    corners.append(torch.tensor([np.cos(angle)*r, np.sin(angle)*r],dtype=torch.float32))

  verts = []
  corner_dir = np.random.randint(2)
  for i in range(n + 1):
    verts.append(corners[i % n])
    verts.append(torch.tensor([corners[(i+corner_dir) % n][0] , corners[(i + 1 - corner_dir) % n][1]]))

  return Mesh.loop(torch.stack(verts[:-1]))


shape = random_shape()
shape.plot()
v = shape.pointcloud(200)
plt.scatter(*v.T)
# %%

train_shape = random_shape()
#%%

maxedges = 18

def gen_data(n):
  train_shapes = [random_shape() for _ in range(n)]
  c = [s.pointcloud(100) for s in train_shapes]
  c = torch.stack(c)
  y = [s.edges for s in train_shapes]
  y = [torch.cat([y.reshape(-1,4), torch.ones(len(y), 1)], dim=1) for y in y]

  y = torch.stack([torch.cat([y, torch.zeros(maxedges - len(y), 5)])for y in y])
  first_point = torch.cat([y[:,:1,:2], torch.ones(len(y),1, 3)], dim=2)
  y = torch.cat([first_point, y], dim=1)
  x = torch.cat([torch.zeros(n, 1, 5), y], dim=1)
  y = torch.cat([y, torch.zeros(n, 1, 5)], dim=1)
  return c, x, y
  
c,x,y = gen_data(10)

#%% 

hdim = 512


class Layer(torch.nn.Module):
  def __init__(self):
    super().__init__()
    
    self.ptsattention = torch.nn.MultiheadAttention(hdim, 4, batch_first=True)
    self.selfattention = torch.nn.MultiheadAttention(hdim, 4, batch_first=True)
    self.ff = torch.nn.Linear(hdim, hdim)
    self.norm = torch.nn.LayerNorm(hdim)
  
  def forward(self, c, x):
    attn_mask = torch.triu(torch.ones(x.shape[1], x.shape[1]), diagonal=1).bool()
    x = self.selfattention.forward(x,x,x, is_causal=True, attn_mask=attn_mask)[0]
    x = self.ptsattention.forward(x,c,c)[0]
    x = self.ff(x.relu())
    x = self.norm(x)
    return x

class Model(torch.nn.Module):
  def __init__(self):
    super().__init__()
    self.ptsadapter = torch.nn.Linear(2, hdim)
    self.edgeadapter = torch.nn.Linear(5, hdim)
    self.layers = [Layer() for _ in range(2)]
    self.out = torch.nn.Linear(hdim, 5)
  
  def forward(self, c, x):
    c = self.ptsadapter(c).relu()
    x = self.edgeadapter(x).relu()
    for layer in self.layers: x = layer(c,x)
    x = self.out(x.relu())
    x[:,:,4] = x[:,:,4].sigmoid()
    return x
    
model = Model()
p = model.forward(c,x)
p.shape
optimizer = torch.optim.Adam(model.parameters(), lr=0.001)

# %%

def loss_fn(p,y):
  ymask = y[:,:,4].unsqueeze(-1)
  geom_loss = (p[:,:,:4] - y[:,:,:4])**2 * ymask
  geom_loss = geom_loss.mean(-1) * ymask.sum(-1)
  geom_loss = geom_loss.mean()
  pmask = p[:,:,4].unsqueeze(-1)
  mask_loss = torch.nn.functional.binary_cross_entropy(pmask, ymask).mean()
  return geom_loss + mask_loss

def step(c,x,y):
  p = model.forward(c,x)
  loss = loss_fn(p,y)
  optimizer.zero_grad()
  loss.backward()
  torch.nn.utils.clip_grad_norm_(model.parameters(), max_norm=1.0)
  optimizer.step()
  return loss.item()

# %%

optimizer.param_groups[0]['lr'] = 0.001
#%%
try:
  for i in range(10000):
    if i % 10 == 0:  c,x,y = gen_data(200)
    if i % 100 == 0: print()
    loss = step(c,x,y)
    print (f'\r {i} {loss}', end='')
except KeyboardInterrupt: pass

#%%

c,x,y = gen_data(1)

p = model.forward(c,x).detach()
y_edges = y.reshape(-1,5)[1:,:4].reshape( -1, 2, 2)
p_edges = p.reshape(-1,5)[1:,:4].reshape( -1, 2, 2)
pmask = p.reshape(-1,5)[1:,4].reshape( -1, 1)

for edge in y_edges: plt.plot(*edge.T, 'black')
for edge,m in zip(p_edges,pmask): 
  if m > 0.5: plt.plot(*edge.T, c=plt.cm.Blues(m.item()))
plt.scatter(*c[0].T, c='gray')
plt.scatter(*y_edges[0,0,:], c='black')
plt.scatter(*p_edges[0,0,:], c='b')

#%% 


def save(self, path): torch.save(self.state_dict(), path)
def load(self, path): self.load_state_dict(torch.load(path))

save(model, "v6")